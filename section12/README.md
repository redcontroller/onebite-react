# 페이지 라우팅

## MPA

> MPA(Multi Page Application)
> 전통적인 웹 서비스 방식으로 서버 사이드 렌더링(Server Side Rendering)을 사용함

MPA 방식의 단점:

1. 페이지 이동 시 페이지의 모든 요소를 교체하기 때문에 새로고침이 발생하여 매끄럽지 않고 비효율적임
2. 다수의 사용자 접속시, 서버의 부하가 심해진다.

## SPA

> SPA(Single Page Application)
> React App이 채택한 방식
> 브라우저에서 Bundle JS File(React 앱)을 실행하는 클라이언트 사이드 렌더링(Client Side Rendering)을 사용함

SPA 방식의 장점:

1. 페이지 내에서 변경이 필요한 컴포넌트만 교체하여 신속하고 효율적으로 페이지를 업데이트 가능
2. 전통적인 방식의 웹 서비스보다 더 쾌적하고 빠르게 페이지 이동이 가능함

## React Router

> React Router
> npmjs.com에 등록되어 있는 라이브러리. 대다수의 리액트 앱이 사용하고 있는 대표적인 라이브러리이다.

```bash
npm i react-router-dom
```

### Routes와 Route

- 원하는 경로에 원하는 컴포넌트를 렌더링 할 수 있다.
- \*(별표)는 위에 있는 경로들이 아닌 나머지 경로로 switch의 default문과 유사하다.
- 주의할 점은 Routes 컴포넌트 하위 자식 컴포넌트로는 Route만 올 수 있다.
- 두번째로 주의할 점은 Routes 컴포넌트 외부에 배치된 요소는 모든 Route 컴포넌트에서 렌더링 된다.
- 모든 페이지에 공통적을 사용될 요소가 아니라면, Routes 컴포넌트 외부에 배치하는 것은 적절치 않다.

### 페이지 라우팅 (Link, useNavigate)

- 버튼이나 링크를 통해서 자유롭게 페이지를 이동하는 방법
- Link 컴포넌트는 HTML의 a태그를 대체하는 컴포넌트이다.
- HTML의 a태그를 이용하면 새로고침되며 클라이언트 사이드 렌더링 방식으로는 페이지 이동이 제공되지 않는다.
- 결론적으로 리액트 앱 내부에서 내부 페이지 이동 링크를 만들어야 한다면 Link 컴포넌트를 사용하는 것이 적절하다.
- 또한 이벤트 핸들러와 함께 사용할 수 있는 useNavigate 커스텀 훅을 사용해서 페이지 이동을 할 수 있다.
- 정리하면 링크가 필요하다면 Link 태그를 사용하고, 이벤트 핸들러 함수 안에서 특정 조건에 따라 페이지 이동이 필요하다면 navigation 함수를 불러올 수 있는 useNavigate 훅을 사용한다.

### 동적 경로 (useParams, useSearchParams)

- 동적 경로: 동적인 데이터를 포함하고 있는 경로
- 상품 ID 같은 동적인 데이터를 포함하고 있는 ~/product/1, ~~/product/2, ... 경로들을 동적 경로라고 말한다.
- 동적 경로에는 URL Parameter 방식과 Query String 방식으로 두 가지 방식이 있다.
- URL Parameter 방식은 슬래시(/) 뒤에 특정 아이템의 ID를 명시하여 작성하고,
- Query String 방식은 물음표(/?) 뒤에 변수 이름을 쓰고 변수를 할당하듯 함께 값을 써주는 형태로 작성한다.
- URL Parameter 방식은 아이템의 id 등의 변경되지 않는 값을 주소로 명시하기 위해 사용되며,
- Query String 방식은 검색어 같이 자주 변경되는 값을 주소로 명시하기 위해 사용된다.
- URL Parameter 방식은 App 컴포넌트 Route 경로에 "/경로/:id"로 명시하고, useParams 커스텀 훅을 사용해서 현재 브라우저 주소창에 명시한 URL 파라미터 값을 가져와서 활용할 수 있다.
- 만약 Query String을 이용한다면, Route 경로 수정 없이 useSearchParams 훅을 사용해 마치 useSate를 사용하는 것처럼 params와 setParams를 받아 변수 값을 읽거나 현재 Query String을 수정할 수 있다. 변수 값을 가져올 때는 params.get("변수명")형태로 메소드를 사용한다.

# 폰트, 이미지, 레이아웃 설정하기

- 이미지는 public 또는 src 하위의 assets 폴더에 둘 수 있다.
- 두 폴더에 위치할 경우 차이점은 public 폴더에 두면 import 없이 경로를 통해 바로 불러올 수 있다.
- assets 폴더에 둔 경우에는 import 를 통해서 불러오는데, 장점으로는 vite를 통해 최적화가 이루어진다.
- 그렇기 때문에 최적화가 필요없는 폰트의 경우 public 폴더에, 최적화가 필요한 이미지는 src 하위 assets에 두는 것이 좋다.
- 이 두가지 케이스를 두고 비교하기 위해서는, 개발모드와 다른 배포 모드에서 확인할 수 있다.

```bash
npm run build // 배포 모드
```

- 최적화된 이미지는 암호문 같은 포맷(base64)을 **데이터 URL**라고 부른다.
  > 데이터 URL는 이미지와 같은 외부 데이터들을 문자열 형태로 브라우저의 메모리에 캐싱하기 위해서 사용하는 포맷이다.
- 데이터 URL 포맷으로 이미지 주소를 설정하게 되면, 불러온 이미지들은 자동으로 브라우저의 메모리에 캐싱(저장) 되어서 새로고침하더라도 다시는 불러오지 않도록 최적화가 된다.
- 반면에 public 폴더에 둔 경로를 통해 불러온 이미지들은 새로고침할 때마다 매번 새롭게 불러온다.
- 확인은 개발자 도구의 네트워크 탭에서 확인할 수 있다.
  > 네트워크 탭은 리액트 앱이 주고받는 모든 네트워크 요청들을 모니터링하는 기능을 제공한다.
- 네트워크 탭에서 Preserve log 옵션을 체크하고, img를 확인해보면 새로고침할 때마다 차이가 발생한다.
- 데이터 URL의 경우 size는 memory cache 되어 용량이 없고, time은 0ms가 찍힌다.
- public 폴더에서 경로로 가져온 이미지의 경우 매번 해당 이미지의 크기인 145B와 6 ~ 30ms가 찍힌다.
- 이미지가 100만개, 200만개가 된다면 굉장히 많은 이미지를 캐싱해두는 것도 문제가 될 수 있다. 이런 상황에서는 public 폴더에 보관하는 것이 더 좋을 수 있다.
- 결론적으로 소수의 이미지를 사용하는 경우에는 src 하위 assets 폴더에 보관해서 사용하여 캐싱되도록 하고, 다수의 이미지를 사용하는 경우 public 폴더에 보관하는 것이 더 좋을 수 있다.

# 공통 컴포넌트 구현하기

- 프로젝트 개발 순서는 사람마다 다르다.
- 이정환 강사님은 페이지 아래와 같은 순서대로 개발을 한다.

1. 페이지 라우팅
2. 글로벌 레이아웃 설정
3. 공통 컴포넌트 구현
4. 개별 페이지 및 복잡한 기능 구현

# [Day 19] 미션 완료!

### 1. vite의 이미지 최적화 기능이 정말 흥미로웠습니다.

\- public은 경로를 통해서 렌더링 시마다 가져오고, assets은 캐싱되어 용도에 맞게 사용하면 되겠어요.
\- Vite가 아닌 일반 CRA 프로젝트는 이미지 최적화 작업을 어떻게 할지 궁금합니다.
\- font의 경우 public 폴더에 들어갔는데, font는 이미 최적화가 되어 있어서 그런걸까요?

### 2. props로 전달되는 html

\- JS강의에서도 본 것 같기도 하지만 props으로 html을 전달하는 방식이 흥미로웠습니다.

### 3. 앵커 태그와 react-router-dom의 Link 태그의 차이

\- 앵커 태그와 Link 태그의 차이점도 알 수 있었고, Link 태그를 적극 활용해야겠네요!

### 4. 동적 경로의 두 가지 방식

\- URL parameter와 Query String 방식을 주소창에서 자주 봤지만 구분이나 차이점을 몰랐는데 이번 기회에 알게되어 좋았습니다.
\- 두 가지 동적 경로의 params를 읽어오거나 수정할 수 있다니 흥미로웠습니다!

### 5. 프로젝트 개발 순서

\- 필요할 때마다 추가하는 방식으로 중구난방으로 개발했었는데, 알려주신 순서를 기준으로 잡으면 좋을 것 같아요
\- 페이지 라우팅 -> 글로벌 레이아웃 설정 -> 공통 컴포넌트 구현 (context 포함) -> 개별 페이지 및 복잡한 기능 구현
